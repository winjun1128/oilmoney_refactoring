<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
  PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
  "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<mapper namespace="review_mapper">

  <!-- 공통 컬럼 -->
  <sql id="col_all">
    ID, REVIEW_KEY, USER_ID, USER_NAME, CLIENT_ID, RATING, TEXT, CREATED_AT, UPDATED_AT
  </sql>

  <!-- resultMap (mine 컬럼 포함) -->
  <resultMap id="RouteReviewMap" type="com.app.dto.route.Review">
    <id     property="id"         column="ID"/>
    <result property="reviewKey"  column="REVIEW_KEY"/>
    <result property="userId"     column="USER_ID"/>
    <result property="userName"   column="USER_NAME"/>
    <result property="clientId"   column="CLIENT_ID"/>
    <result property="rating"     column="RATING"/>
    <result property="text"       column="TEXT"/>
    <result property="createdAt"  column="CREATED_AT"/>
    <result property="updatedAt"  column="UPDATED_AT"/>
    <result property="mine"       column="MINE"/>
  </resultMap>

  <!-- INSERT: Oracle 시퀀스 사용 -->
  <insert id="insertReview" parameterType="com.app.dto.route.Review">
    <selectKey keyProperty="id" order="BEFORE" resultType="long">
      SELECT REVIEWS_SEQ.NEXTVAL FROM DUAL
    </selectKey>
    INSERT INTO T_REVIEWS
      (ID, REVIEW_KEY, USER_ID, USER_NAME, CLIENT_ID, RATING, TEXT)
    VALUES
      (#{id}, #{reviewKey}, #{userId}, #{userName}, #{clientId}, #{rating}, #{text})
  </insert>

  <!-- UPDATE (소유자만) -->
  <update id="updateReviewByOwner">
    UPDATE T_REVIEWS
       SET RATING = #{rating},
           TEXT   = #{text}
     WHERE ID = #{id}
       AND USER_ID = #{userId}
  </update>

  <!-- DELETE (소유자만) -->
  <delete id="deleteReviewByOwner">
    DELETE FROM T_REVIEWS
     WHERE ID = #{id}
       AND USER_ID = #{userId}
  </delete>


 <!-- mine 계산을 위해 파라미터 userId 받으면 좋지만 단건은 항상 0으로  -->
  <!-- 단건 조회(소유 검증 등) -->
  <select id="selectOne" parameterType="long" resultMap="RouteReviewMap">
    SELECT <include refid="col_all"/> ,
           0 AS MINE
      FROM T_REVIEWS
     WHERE ID = #{id}
  </select>

  <!-- 리스트 (키 기준 + 페이징 + mine 계산)
       Oracle 12c+ OFFSET/FETCH 문법 사용 -->
  <select id="selectByKeyPaged" resultMap="RouteReviewMap">
    SELECT <include refid="col_all"/>,
           CASE WHEN USER_ID = #{userId} THEN 1 ELSE 0 END AS MINE
      FROM T_REVIEWS
     WHERE REVIEW_KEY = #{reviewKey}
     ORDER BY CREATED_AT DESC
     OFFSET #{offset} ROWS FETCH NEXT #{size} ROWS ONLY
  </select>

  <!-- 집계 -->
  <select id="selectAggByKey" resultType="com.app.dto.route.ReviewAgg">
    SELECT NVL(AVG(RATING), 0) AS avgRating, COUNT(*) AS count
      FROM T_REVIEWS
     WHERE REVIEW_KEY = #{reviewKey}
  </select>

  <!-- 총 개수 (hasMore 계산용, 선택) -->
  <select id="countByKey" resultType="int">
    SELECT COUNT(*) FROM T_REVIEWS WHERE REVIEW_KEY = #{reviewKey}
  </select>

</mapper>
