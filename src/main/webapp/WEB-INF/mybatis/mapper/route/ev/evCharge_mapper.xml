<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
  "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="evCharge_mapper">

  <!-- 충전소 STATID 전체 -->
  <select id="selectAllStatIds" resultType="string">
    <![CDATA[
      SELECT DISTINCT STATID
      FROM T_CHARGE
      WHERE STATID IS NOT NULL
    ]]>
  </select>

  <!-- 충전소 목록 조회 -->
  <select id="selectEvInfo" resultType="com.app.dto.route.EvCharge">
    <![CDATA[
      SELECT
        STATID, STATNM, ADDR, LAT, LNG,
        USETIME,
        ZCODE, SCODE, FLOORNUM, FLOORTYPE,
        BUSID, BUSINM, BUSICALL,
        UPDATED_AT
      FROM T_CHARGE
      ORDER BY UPDATED_AT DESC NULLS LAST
    ]]>
  </select>

 <insert id="mergeEvCharge" parameterType="com.app.dto.route.EvCharge">
<![CDATA[
MERGE INTO T_CHARGE t
USING (SELECT
         #{statId}    STATID,
         #{statNm}    STATNM,
         #{addr}      ADDR,
         #{lat,jdbcType=VARCHAR}  LAT,
         #{lng,jdbcType=VARCHAR}  LNG,
         #{useTime}   USETIME,
         #{zcode}     ZCODE,
         #{scode}     SCODE,
         #{floorNum}  FLOORNUM,
         #{floorType} FLOORTYPE,
         #{busId}     BUSID,
         #{busiNm}    BUSINM,
         #{busiCall}  BUSICALL
       FROM dual) s
ON (t.STATID = s.STATID)

WHEN MATCHED THEN UPDATE SET
     t.STATNM     = NVL(s.STATNM,     t.STATNM)
   , t.ADDR       = NVL(s.ADDR,       t.ADDR)
   , t.LAT        = NVL(s.LAT,        t.LAT)
   , t.LNG        = NVL(s.LNG,        t.LNG)
   , t.USETIME = NVL(NULLIF(TRIM(s.USETIME), ''), t.USETIME) -- 업데이트는 기존 로직 유지
   , t.ZCODE      = NVL(s.ZCODE,      t.ZCODE)
   , t.SCODE      = NVL(s.SCODE,      t.SCODE)
   , t.FLOORNUM   = NVL(s.FLOORNUM,   t.FLOORNUM)
   , t.FLOORTYPE = NVL(NULLIF(SUBSTR(TRIM(s.FLOORTYPE), 1, 1), ''), t.FLOORTYPE)
   , t.BUSID      = NVL(s.BUSID,      t.BUSID)
   , t.BUSINM     = NVL(s.BUSINM,     t.BUSINM)
   , t.BUSICALL   = NVL(NULLIF(TRIM(s.BUSICALL), ''), t.BUSICALL)
   , t.UPDATED_AT = SYSTIMESTAMP

WHEN NOT MATCHED THEN INSERT
  (STATID, STATNM, ADDR, LAT, LNG, USETIME, ZCODE, SCODE,
   FLOORNUM, FLOORTYPE, BUSID, BUSINM, BUSICALL, UPDATED_AT)
VALUES
  (s.STATID, s.STATNM, s.ADDR, s.LAT, s.LNG,
   NVL(NULLIF(TRIM(s.USETIME), ''), '정보없음'),   -- ★ 여기!
   s.ZCODE, s.SCODE,
   NVL(NULLIF(TRIM(s.FLOORNUM),   ''), '정보없음'),
   NVL(NULLIF(SUBSTR(TRIM(s.FLOORTYPE),1,1), ''), 'N'), s.BUSID, s.BUSINM, NVL(NULLIF(TRIM(s.BUSICALL), ''), '정보없음'), SYSTIMESTAMP)
]]>
</insert>







  <!-- 타입 마스터 -->
  <insert id="mergeChargerType" parameterType="com.app.dto.route.ChargerType">
    <![CDATA[
      MERGE INTO T_CHARGER_TYPE t
      USING (SELECT #{typeCd} TYPE_CD, #{typeNm} TYPE_NM FROM dual) s
      ON (t.TYPE_CD = s.TYPE_CD)
      WHEN MATCHED THEN UPDATE SET t.TYPE_NM = s.TYPE_NM
      WHEN NOT MATCHED THEN INSERT (TYPE_CD, TYPE_NM) VALUES (s.TYPE_CD, s.TYPE_NM)
    ]]>
  </insert>

 <!-- 충전기(포트) 스냅샷 : 부모/타입 존재할 때만 INSERT -->
<insert id="mergeCharger" parameterType="com.app.dto.route.Charger">
  <![CDATA[
    MERGE INTO T_CHARGER t
    USING (SELECT
             #{statId}  STATID,
             #{chgerId} CHGERID,
             #{typeCd}  TYPE_CD,
             #{method}  METHOD,
             #{outputKw,jdbcType=NUMERIC} OUTPUT_KW
           FROM dual) s
    ON (t.STATID = s.STATID AND t.CHGERID = s.CHGERID)

    WHEN MATCHED THEN UPDATE SET
         t.TYPE_CD    = s.TYPE_CD,
         t.METHOD     = s.METHOD,
         -- ⛑ NULL 덮어쓰기 방지(유지하고 싶으면 이대로)
         t.OUTPUT_KW  = CASE WHEN s.OUTPUT_KW IS NOT NULL THEN s.OUTPUT_KW ELSE t.OUTPUT_KW END,
         t.UPDATED_AT = SYSTIMESTAMP

    WHEN NOT MATCHED THEN INSERT
      (STATID, CHGERID, TYPE_CD, METHOD, OUTPUT_KW, UPDATED_AT)
    VALUES
      (s.STATID, s.CHGERID, s.TYPE_CD, s.METHOD, s.OUTPUT_KW, SYSTIMESTAMP)
    -- 부모/타입 없으면 INSERT 스킵(유지 권장)
    WHERE EXISTS (SELECT 1 FROM T_CHARGE p WHERE p.STATID = s.STATID)
      AND EXISTS (SELECT 1 FROM T_CHARGER_TYPE tt WHERE tt.TYPE_CD = s.TYPE_CD)
  ]]>
</insert>



  <!-- 상태 증분 -->
 <insert id="mergeStatus" parameterType="com.app.dto.route.ChargerStatus">
<![CDATA[
MERGE INTO T_CHARGER_STATUS t
USING (
  SELECT *
  FROM (
    SELECT
      #{statId}    STATID,
      #{chgerId}   CHGERID,
      #{stat}      STAT,
      #{statUpdDt} STAT_UPD_DT,
      #{lastTsdt}  LAST_TSDT,
      #{lastTedt}  LAST_TEDT,
      #{nowTsdt}   NOW_TSDT
    FROM dual
  ) s
  WHERE EXISTS (
    SELECT 1
    FROM T_CHARGER c
    WHERE c.STATID = s.STATID
      AND c.CHGERID = s.CHGERID
  )
) s
ON (t.STATID = s.STATID AND t.CHGERID = s.CHGERID)
WHEN MATCHED THEN UPDATE SET
  t.STAT        = s.STAT,
  t.STAT_UPD_DT = s.STAT_UPD_DT,
  t.LAST_TSDT   = s.LAST_TSDT,
  t.LAST_TEDT   = s.LAST_TEDT,
  t.NOW_TSDT    = s.NOW_TSDT,
  t.UPDATED_AT  = SYSTIMESTAMP
WHERE NVL(t.STAT_UPD_DT,'0') < NVL(s.STAT_UPD_DT,'0')
WHEN NOT MATCHED THEN INSERT
  (STATID, CHGERID, STAT, STAT_UPD_DT, LAST_TSDT, LAST_TEDT, NOW_TSDT, UPDATED_AT)
VALUES
  (s.STATID, s.CHGERID, s.STAT, s.STAT_UPD_DT, s.LAST_TSDT, s.LAST_TEDT, s.NOW_TSDT, SYSTIMESTAMP)
]]>
</insert>


<!-- mapper: DB에 있는 모든 포트 키 (STATID|CHGERID) -->
<select id="selectAllChargerKeys" resultType="string">
  SELECT STATID || '|' || CHGERID AS k
  FROM T_CHARGER
</select>

<!-- ev 조회 -->
<!-- 상태테이블 조인 -->
<select id="selectChargerStatusByStatIds" parameterType="map" resultType="map">
  SELECT
    c.STATID     AS "statId",
    c.CHGERID    AS "chgerId",
    c.TYPE_CD    AS "chgerType",
    c.METHOD     AS "method",
    c.OUTPUT_KW  AS "output",
    s.STAT       AS "stat",
    -- STAT_UPD_DT 타입이 DATE/TIMESTAMP면 TO_CHAR, 문자면 그대로 사용
    /* TO_CHAR(s.STAT_UPD_DT, 'YYYY-MM-DD HH24:MI:SS') AS "statUpdDt" */
    s.STAT_UPD_DT AS "statUpdDt"
  FROM T_CHARGER c
  LEFT JOIN T_CHARGER_STATUS s
    ON s.STATID = c.STATID AND s.CHGERID = c.CHGERID
  WHERE c.STATID IN
  <foreach collection="statIds" item="id" open="(" separator="," close=")">#{id}</foreach>
  ORDER BY c.STATID, c.CHGERID
</select>

<!-- 폴백: 상태 없이 기본정보만 -->
<select id="selectChargersByStatIds" parameterType="map" resultType="map">
  SELECT
    c.STATID     AS "statId",
    c.CHGERID    AS "chgerId",
    c.TYPE_CD    AS "chgerType",
    c.METHOD     AS "method",
    c.OUTPUT_KW  AS "output",
    NULL         AS "stat",
    NULL         AS "statUpdDt"
  FROM T_CHARGER c
  WHERE c.STATID IN
  <foreach collection="statIds" item="id" open="(" separator="," close=")">#{id}</foreach>
  ORDER BY c.STATID, c.CHGERID
</select>

<!-- EvChargeMapper.xml -->
 <!-- 충전가능(stat='2')이면서 선택적 조건(type/minKw/zcode)을 만족하는 지점 집합 -->
 <!-- 충전가능(stat='2')이면서 선택적 조건(type/minKw/zcode)을 만족하는 지점 집합 -->
<!-- 충전가능(stat='2')이면서 type/minKw/zcode 조건까지 만족하는 statid 목록 -->
<!-- EvChargeMapper.xml: 가용 지점 조회 (상태=2 + 타입필터만) -->
<select id="selectAvailableStatIds" parameterType="map" resultType="string">
  SELECT t.statid
  FROM (
    SELECT
      cs.STATID AS statid,
      /* DC 계열 */
      MAX(CASE WHEN c.TYPE_CD IN ('01','03','04','05','06','08') THEN 1 ELSE 0 END) AS has_dc,
      /* AC 계열 */
      MAX(CASE WHEN c.TYPE_CD IN ('02','03','06','07','08') THEN 1 ELSE 0 END)       AS has_ac
    FROM T_CHARGER_STATUS cs
    JOIN T_CHARGER c
      ON c.STATID  = cs.STATID
     AND c.CHGERID = cs.CHGERID   <!-- 컬럼명 주의: CHGERID -->
    WHERE cs.STAT = '2'
    <if test="zcode != null">
      AND EXISTS (
        SELECT 1
        FROM T_CHARGE m
        WHERE m.STATID = cs.STATID
          AND m.ZCODE  = #{zcode}
      )
    </if>
    GROUP BY cs.STATID
  ) t
  WHERE 1=1
  <choose>
    <when test="type == 'dc'">    AND t.has_dc = 1 </when>
    <when test="type == 'ac'">    AND t.has_ac = 1 </when>
    <when test="type == 'combo'"> AND t.has_dc = 1 AND t.has_ac = 1 </when>
    <!-- null/'any'면 조건 없음 -->
  </choose>
</select>




  <!--
  ※ (참고) denormalize 미적용일 때(=상태테이블에 CHGER_TYPE/OUTPUT_KW가 없을 때) 조인 버전
  <select id="selectAvailableStatIds" parameterType="map" resultType="string">
    <![CDATA[
    SELECT statid
    FROM (
      SELECT
        cs.STATID AS statid,
        MAX(CASE WHEN c.TYPE_CD IN ('01','03','04','05','06','08') THEN 1 ELSE 0 END) AS has_dc,
        MAX(CASE WHEN c.TYPE_CD IN ('02','03','06','07','08') THEN 1 ELSE 0 END) AS has_ac,
        MAX(NVL(c.OUTPUT_KW,0)) AS max_kw
      FROM T_CHARGER_STATUS cs
      JOIN T_CHARGER c
        ON c.STATID = cs.STATID AND c.CHGERID = cs.CHGERID
      WHERE cs.STAT = '2'
        AND EXISTS (SELECT 1 FROM T_CHARGE ch WHERE ch.STATID = cs.STATID
                                           AND (#{zcode} IS NULL OR ch.ZCODE = #{zcode}))
      GROUP BY cs.STATID
    )
    WHERE 1=1
      AND (
        #{type} = 'any'
        OR (#{type} = 'dc'    AND has_dc = 1)
        OR (#{type} = 'ac'    AND has_ac = 1)
        OR (#{type} = 'combo' AND has_dc = 1 AND has_ac = 1)
      )
      AND (#{minKw,jdbcType=NUMERIC} IS NULL OR max_kw >= #{minKw})
    ]]>
  </select>
  -->




</mapper>
